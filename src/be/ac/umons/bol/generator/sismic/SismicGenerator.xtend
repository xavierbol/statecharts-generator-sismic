package be.ac.umons.bol.generator.sismic

import org.yakindu.sct.model.sgen.GeneratorEntry
import org.eclipse.xtext.generator.IFileSystemAccess
import org.yakindu.sct.generator.core.ISGraphGenerator
import org.yakindu.sct.model.sgraph.Statechart
import java.io.FileOutputStream
import java.io.File
import org.yakindu.sct.model.sgraph.Region
import org.yakindu.sct.model.sgraph.Entry
import org.yakindu.sct.model.sgraph.State
import org.yakindu.sct.model.sgraph.Transition
import be.ac.umons.bol.generator.sismic.specification.SpecificationState
import java.util.ArrayList
import be.ac.umons.bol.generator.sismic.specification.SpecificationRoot
import org.yakindu.sct.model.sgraph.FinalState
import org.yakindu.sct.model.sgraph.EntryKind
import be.ac.umons.bol.generator.sismic.specification.SpecificationTransition
import org.yakindu.sct.model.sgraph.Choice
import org.yakindu.sct.model.sgraph.Synchronization

/**
 * Generator to create a statechart for Sismic library in Python
 * Sismic library use YAML file to define a statechart.
 * 
 * TODO:
 *  - Vérifier la gestion des évènements always et oncycle
 * 	- Gérer plusieurs interfaces créées dans un même statechart
 */
class SismicGenerator implements ISGraphGenerator {
	ArrayList<be.ac.umons.bol.generator.sismic.specification.Transition> listTransitionSuppl = null
	SpecificationRoot specificationRoot
	ArrayList <FinalState> listFinalState = new ArrayList

	/**
	 * Generate an output file with the generating of Statechart
	 */
	override generate(Statechart sc, GeneratorEntry entry, IFileSystemAccess fsa) {
		specificationRoot = new SpecificationRoot(sc.specification)
		var result = sc.generate as String
		
		// Replace tabulation generated by the template expressions by 2 whitespaces 
		// because in Sismic, we get an error if \t is before any token
		result = result.replaceAll("\t", "  ");
		
		fsa.generateFile(sc.name + '.yaml', result)
		fsa.generateFile(sc.name + '.py', SismicInterpreter.content(sc, specificationRoot))
	}

	/**
	 * Generate a template for statechart object
	 */
	def dispatch String generate(Statechart it) '''
		statechart:
			name: «it.name»
			«new SpecificationRoot(specification).generateYAML»
			root state:
				name: root
				«IF regions.length > 1»
					parallel states:
						«FOR region : regions»
						- name: «region.name»
						  «region.generate»
						«ENDFOR»
				«ELSE»
					«regions.head.generate»
				«ENDIF»
	'''
	
	/**
	 * Search the name of the first state treated in the current region
	 * 
	 * region : the current region
	 */
	def private String initialState(Region region) {
		region.vertices.filter(Entry).head.outgoingTransitions.head.target.name
	}
	
	/**
	 * Search a history State in the current region
	 * 
	 * region : the current region
	 * 
	 * return the entry that is a history state or null if there is no history state
	 */
	def private Entry historyState(Region region) {
		val entry = region.vertices.filter(Entry)
		
		if (entry !== null) {
			for (e : entry) {
				if (e.kind !== EntryKind.INITIAL) {
					return e
				}
			}			
		}
		
		return null
	}
	
	/**
	 * Generate an region
	 * This region can be :
	 * 	- The first region of the statechart
	 *  - Other region of the Statechart
	 * 
	 * if it's the first region, it will add name and initial keyword in YAML file
	 */
	def dispatch String generate(Region it) '''
		«IF vertices.filter(Entry).head !== null»
			initial: «initialState»
	  	«ENDIF»
		states:
			«FOR vertex : vertices.filter(State)»
				«vertex.generate»
			«ENDFOR»
			«FOR finalState : listFinalState»
				«finalState.generate»
			«ENDFOR»
			«IF historyState !== null»
				«historyState.generate»
			«ENDIF»«listFinalState.clear»
			«FOR vertex : vertices.filter(Choice)»
				«vertex.generate»
			«ENDFOR»
			«FOR vertex : vertices.filter(Synchronization)»
				«vertex.generate»
			«ENDFOR»
	'''
	
	/**
	 * Generate State of the statechart
	 * In Yakindu, a state is a Vertex with a type State
	 */
	def dispatch String generate(State it) {
		val specificationState = new SpecificationState(name, specification)
		
		val exist_transitions = outgoingTransitions.size > 0 || (specificationState.listOtherEvent !== null && !specificationState.listOtherEvent.isEmpty)
		var transitions = ""
		
		if (exist_transitions) {
			transitions = '''
				«IF specificationState.listOtherEvent !== null && !specificationState.listOtherEvent.isEmpty»
				  	«FOR transition : specificationState.listOtherEvent»
				  		«transition.generate»
					«ENDFOR»
			  	«ENDIF»
			  	«IF outgoingTransitions.size > 0»
				    «FOR transition : outgoingTransitions»
				      «transition.generate(specificationState.transition)»
				    «ENDFOR»
				«ELSEIF specificationState.transition !== null»
					«specificationState.transition.generate»
			    «ENDIF»
			'''
		}
		
		return '''
			- name: «name»
			  «specificationState.generate»
			  «IF exist_transitions»
			  transitions:
			  	«transitions»
			  «ENDIF»
			  «IF isOrthogonal»
			  	parallel states:
			  		«IF specificationState.everyEvent !== null»
			  			«specificationState.everyEvent.generate»
			  		«ENDIF»
			  		«FOR region : regions»
			  			- name: «region.name»
			  			  «region.generate»
			  		«ENDFOR»
			  «ELSEIF isComposite»
			  	«IF specificationState.everyEvent !== null»
			  		parallel states:
			  		  - name: region_every
			  		  «specificationState.everyEvent.generate»
		  		«ENDIF»
			  	«regions.head.generate»
			  «ELSEIF specificationState.everyEvent !== null»
			  	«specificationState.everyEvent.generate»
			  «ENDIF»
		'''
	}
	
	/**
	 * Generate the final states
	 * Normally this final states are detected in outgoingTransition of the others states
	 */
	def dispatch String generate(FinalState it) '''
		- name: «name»
		  type: final
	'''
	
	def dispatch String generate(Choice it) {
		throw new Exception("The Choice state isn't managed by this generator...")
	}
	
	def dispatch String generate(Synchronization it) {
		throw new Exception("Impossible to generate the synchronization bar into statechart for Sismic...")
	}
	
	/**
	 * Generate the history states
	 * Yakindu define the history as an initial state with an attribute kind
	 * to find the enumeration of this state
	 * A history state has as value in kind attribute :
	 * 	- EntryKind.DEEP_HISTORY
	 * 	- EntryKind.SHALLOW_HISTORY
	 */
	def dispatch String generate(Entry it) {
		var history = ""
		
		if (kind == EntryKind.DEEP_HISTORY) {
			history = "deep history"
		} else if (kind == EntryKind.SHALLOW_HISTORY) {
			history = "shallow history"
		}
		
		return '''
			- name: «name»
			  type: «history»
		'''
	}
	
	/**
	 * Generate Transition of a state
	 */
	def CharSequence generate(Transition it, be.ac.umons.bol.generator.sismic.specification.Transition transition) {
		val spec = new SpecificationTransition(specification)
		
		if (target instanceof FinalState) { // It must check if the final already exists in this list
			target.name = target.parentRegion.name + "_final" + (listFinalState.length + 1)
			listFinalState.add(target as FinalState)
		}
		
		if (transition !== null && spec.haveSameTrigger(transition.specification)) { // Then add all actions into this current transition
			spec.mergeSpecification(transition.specification)
		}
		
		return '''
			- target: «target.name»
			  «spec.generate»
		'''
	}

	def write(File dir, String filename, String content) {
		dir.mkdirs
		val bos = new FileOutputStream(new File(dir.path + File::separator + filename))
		bos.write(content.bytes)
		bos.close
	}
}
