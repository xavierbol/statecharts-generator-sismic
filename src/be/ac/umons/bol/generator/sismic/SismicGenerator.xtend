package be.ac.umons.bol.generator.sismic

import org.yakindu.sct.model.sgen.GeneratorEntry
import org.eclipse.xtext.generator.IFileSystemAccess
import org.yakindu.sct.generator.core.ISGraphGenerator
import org.yakindu.sct.model.sgraph.Statechart
import java.io.FileOutputStream
import java.io.File
import org.yakindu.sct.model.sgraph.Region
import org.yakindu.sct.model.sgraph.Entry
import org.yakindu.sct.model.sgraph.State
import org.yakindu.sct.model.sgraph.Transition
import be.ac.umons.bol.generator.sismic.specification.SpecificationTransition
import be.ac.umons.bol.generator.sismic.specification.SpecificationState
import java.util.ArrayList
import be.ac.umons.bol.generator.sismic.specification.SpecificationRoot
import org.yakindu.sct.model.sgraph.FinalState
import org.yakindu.sct.model.sgraph.EntryKind

/**
 * Generator to create a statechart for Sismic library in Python
 * Sismic library use YAML file to define a statechart.
 * 
 * TODO:
 *  - Vérifier la gestion des évènements always et oncycle
 * 	- Gérer plusieurs interfaces créées dans un même statechart
 */
class SismicGenerator implements ISGraphGenerator {
	ArrayList<be.ac.umons.bol.generator.sismic.specification.Transition> listTransitionSuppl = null
	SpecificationRoot specificationRoot
	ArrayList <FinalState> listFinalState = new ArrayList

	/**
	 * Generate an output file with the generating of Statechart
	 */
	override generate(Statechart sc, GeneratorEntry entry, IFileSystemAccess fsa) {
		specificationRoot = new SpecificationRoot(sc.specification)
		var result = sc.generate as String
		
		// Replace tabulation generated by the template expressions by 2 whitespaces 
		// because in Sismic, we get an error if \t is before any token
		result = result.replaceAll("\t", "  ");
		
		fsa.generateFile(sc.name + '.yaml', result)
		fsa.generateFile(sc.name + '.py', SismicInterpreter.content(sc, specificationRoot))
	}

	/**
	 * Generate a template for statechart object
	 */
	def dispatch String generate(Statechart it) '''
		statechart:
			name: «it.name»
			«new SpecificationRoot(specification).generateYAML»
			root state:
				name: root
				«IF regions.length > 1»
					parallel states:
						«FOR region : regions»
						- name: «region.name»
						  «region.generate»
						«ENDFOR»
				«ELSE»
					«regions.head.generate»
				«ENDIF»
	'''
	
	/**
	 * Search the name of the first state treated in the current region
	 * 
	 * region : the current region
	 */
	def private String initialState(Region region) {
		region.vertices.filter(Entry).head.outgoingTransitions.head.target.name
	}
	
	/**
	 * Search a history State in the current region
	 * 
	 * region : the current region
	 * 
	 * return the entry that is a history state or null if there is no history state
	 */
	def private Entry historyState(Region region) {
		val entry = region.vertices.filter(Entry)
		
		if (entry !== null) {
			for (e : entry) {
				if (e.kind !== EntryKind.INITIAL) {
					return e
				}
			}			
		}
		
		return null
	}
	
	/**
	 * Generate an region
	 * This region can be :
	 * 	- The first region of the statechart
	 *  - Other region of the Statechart
	 * 
	 * if it's the first region, it will add name and initial keyword in YAML file
	 */
	def dispatch CharSequence generate(Region it) '''
		«IF vertices.filter(Entry).head !== null»
			initial: «initialState»
	  	«ENDIF»
		states:
			«FOR vertex : vertices.filter(State)»
				«vertex.generate»
			«ENDFOR»
			«FOR finalState : listFinalState»
				«finalState.generate»
			«ENDFOR»
			«IF historyState !== null»
				«historyState.generate»
			«ENDIF»
	'''
	
	/**
	 * Generate State of the statechart
	 * In Yakindu, a state is a Vertex with a type State
	 */
	def dispatch CharSequence generate(State it) {
		val specificationState = new SpecificationState(name, specification)
		
		return '''
			- name: «name»
			  «specificationState.generate»
			  «IF outgoingTransitions.size > 0»
			  transitions:
			    «FOR transition : outgoingTransitions»
			      «transition.generate»
			    «ENDFOR»
			  «ENDIF»
			  «IF isOrthogonal»
			  	parallel states:
			  		«IF specificationState.everyEvent !== null»
			  			«specificationState.everyEvent.generate»
			  		«ENDIF»
			  		«FOR region : regions»
			  			- name: «region.name»
			  			  «region.generate»
			  		«ENDFOR»
			  «ELSEIF isComposite»
			  	«IF specificationState.everyEvent !== null»
			  		parallel states:
			  		  - name: region_every
			  		  «specificationState.everyEvent.generate»
		  		«ENDIF»
			  	«regions.head.generate»
			  «ELSEIF specificationState.everyEvent !== null»
			  	«specificationState.everyEvent.generate»
			  «ENDIF»
		'''
	}
	
	/**
	 * Generate the final states
	 * Normally this final states are detected in outgoingTransition of the others states
	 */
	def dispatch CharSequence generate(FinalState it) '''
		- state: «name»
		  type: final
	'''
	
	/**
	 * Generate the history states
	 * Yakindu define the history as an initial state with an attribute kind
	 * to find the enumeration of this state
	 * A history state has as value in kind attribute :
	 * 	- EntryKind.DEEP_HISTORY
	 * 	- EntryKind.SHALLOW_HISTORY
	 */
	def dispatch CharSequence generate(Entry it) {
		var history = ""
		
		if (kind == EntryKind.DEEP_HISTORY) {
			history = "deep history"
		} else if (kind == EntryKind.SHALLOW_HISTORY) {
			history = "shallow history"
		}
		
		return '''
			- name: «name»
			  type: «history»
		'''
	}
	
	/**
	 * Generate Transition of a state
	 */
	def dispatch CharSequence generate(Transition it) {
		if (target instanceof FinalState) {
			target.name = target.parentRegion.name + "_final" + (listFinalState.length + 1)
			listFinalState.add(target as FinalState)
		}
		
		return '''
			- target: «target.name»
			  «new SpecificationTransition(specification).generate»
		'''
	}
	
	/**
	 * Generate the data extracted in the specification of the outgoingTransition tag.
	 */
	def dispatch CharSequence generate(SpecificationTransition it) '''
		«IF !event.empty»
			event: «event»
		«ENDIF»
		«IF !guard.empty»
			guard: «guard»
		«ENDIF»
		«IF listActions !== null && !listActions.empty»
			«IF listActions.length == 1»
				action: «listActions.get(0)»
			«ELSE»
				action: |
					«FOR action : listActions»
						«action»
					«ENDFOR»
			«ENDIF»
		«ENDIF»
	'''

	def write(File dir, String filename, String content) {
		dir.mkdirs
		val bos = new FileOutputStream(new File(dir.path + File::separator + filename))
		bos.write(content.bytes)
		bos.close
	}
}
