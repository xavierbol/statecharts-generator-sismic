package be.ac.umons.bol.generator.sismic

import org.yakindu.sct.model.sgen.GeneratorEntry
import org.eclipse.xtext.generator.IFileSystemAccess
import org.yakindu.sct.generator.core.ISGraphGenerator
import org.yakindu.sct.model.sgraph.Statechart
import java.io.FileOutputStream
import java.io.File
import org.yakindu.sct.model.sgraph.Region
import org.yakindu.sct.model.sgraph.Entry
import org.yakindu.sct.model.sgraph.State
import org.yakindu.sct.model.sgraph.Transition
import be.ac.umons.bol.generator.sismic.specification.SpecificationState
import java.util.ArrayList
import be.ac.umons.bol.generator.sismic.specification.SpecificationRoot
import org.yakindu.sct.model.sgraph.FinalState
import org.yakindu.sct.model.sgraph.EntryKind
import be.ac.umons.bol.generator.sismic.specification.SpecificationTransition
import org.yakindu.sct.model.sgraph.Choice
import org.yakindu.sct.model.sgraph.Synchronization

/**
 * Français :
 * Ce générateur convertit un statechart défini dans Yakindu Statechart Tools en un statechart pour la librarie Python, Sismic.
 * Pour créer un statechart défini en Sismic, le générateur doit créer un fichier YAML définissant le statechart.
 * Cet outil crée également un autre fichier, un fichier Python.
 * Dans ce fichier Python, il y a l'importation de l'interpréteur Sismic, avec un petit modèle pour commencer l'interprétation
 * du statechart généré.
 * 
 * English :
 * This generator convert a statechart defined in Yakindu Statechart Tools into a statechart for Sismic library in Python.
 * To create a statechart defined in Sismic library, the generator must create a YAML file to define the statechart.
 * This tool create also another file, a Python file.
 * In this Python file, there are the importation of the interpreter Sismic, with a little template to beginning 
 * the interpretation of the generated statechart.
 */
class SismicGenerator implements ISGraphGenerator {
	SpecificationRoot specificationRoot
	ArrayList <FinalState> listFinalState = new ArrayList

	/**
	 * Generate an output file with the generating of Statechart
	 */
	override generate(Statechart sc, GeneratorEntry entry, IFileSystemAccess fsa) {
		specificationRoot = new SpecificationRoot(sc.specification)
		var result = sc.generate as String
		
		// Replace tabulation generated by the template expressions by 2 whitespaces 
		// because in Sismic, we get an error if \t is before any token
		result = result.replaceAll("\t", "  ");
		
		fsa.generateFile(sc.name + '.yaml', result)
		fsa.generateFile(sc.name + '.py', SismicInterpreter.content(sc, specificationRoot))
	}

	/**
	 * Generate a template for statechart object
	 * 
	 * @param it : the object of Statechart
	 * 
	 * @return the template
	 */
	def dispatch String generate(Statechart it) '''
		statechart:
			name: «it.name»
			«new SpecificationRoot(specification).generateYAML»
			root state:
				name: root
				«IF regions.length > 1»
					parallel states:
						«FOR region : regions»
						- name: «region.name»
						  «region.generate»
						«ENDFOR»
				«ELSE»
					«regions.head.generate»
				«ENDIF»
	'''
	
	/**
	 * Search the name of the first state treated in the current region
	 * 
	 * @param region : the current region
	 * 
	 * @return the initialState of the region
	 */
	def private String initialState(Region region) {
		region.vertices.filter(Entry).head.outgoingTransitions.head.target.name
	}
	
	/**
	 * Search a history State in the current region
	 * 
	 * @param region : the current region
	 * 
	 * @return the entry that is a history state or null if there is no history state
	 */
	def private Entry historyState(Region region) {
		val entry = region.vertices.filter(Entry)
		
		if (entry !== null) {
			for (e : entry) {
				if (e.kind !== EntryKind.INITIAL) {
					return e
				}
			}			
		}
		
		return null
	}
	
	/**
	 * Generate a template for an region
	 * 
	 * This region can be :
	 * 	- The first region of the statechart
	 *  - Other region of the Statechart
	 * 
	 * if this region contains an entry state, it will add name and initial keyword in YAML file
	 * 
	 * @param the region
	 * 
	 * @return the template
	 */
	def dispatch String generate(Region it) '''
		«IF vertices.filter(Entry).head !== null»
			initial: «initialState»
	  	«ENDIF»
		states:
			«FOR vertex : vertices.filter(State)»
				«vertex.generate»
			«ENDFOR»
			«FOR finalState : listFinalState»
				«finalState.generate»
			«ENDFOR»
			«IF historyState !== null»
				«historyState.generate»
			«ENDIF»«listFinalState.clear»
			«FOR vertex : vertices.filter(Choice)»
				«vertex.generate»
			«ENDFOR»
			«FOR vertex : vertices.filter(Synchronization)»
				«vertex.generate»
			«ENDFOR»
	'''
	
	/**
	 * Generate a template for a state of the statechart
	 * 
	 * In Yakindu, a state is a Vertex with a type State
	 * 
	 * @param a state in statechart of Yakindu
	 * 
	 * @return the template
	 */
	def dispatch String generate(State it) {
		val specificationState = new SpecificationState(name, specification)
		
		val exist_transitions = outgoingTransitions.size > 0 || (specificationState.listOtherEvent !== null && !specificationState.listOtherEvent.isEmpty)
		var transitions = ""
		
		if (exist_transitions) {
			transitions = '''
				«IF specificationState.listOtherEvent !== null && !specificationState.listOtherEvent.isEmpty»
				  	«FOR transition : specificationState.listOtherEvent»
				  		«transition.generate»
					«ENDFOR»
			  	«ENDIF»
			  	«IF outgoingTransitions.size > 0»
				    «FOR transition : outgoingTransitions»
				      «transition.generate(specificationState.transition)»
				    «ENDFOR»
				«ELSEIF specificationState.transition !== null»
					«specificationState.transition.generate»
			    «ENDIF»
			'''
		}
		
		return '''
			- name: «name»
			  «specificationState.generate»
			  «IF exist_transitions»
			  transitions:
			  	«transitions»
			  «ENDIF»
			  «IF isOrthogonal»
			  	parallel states:
			  		«IF specificationState.everyEvent !== null»
			  			«specificationState.everyEvent.generate»
			  		«ENDIF»
			  		«FOR region : regions»
			  			- name: «region.name»
			  			  «region.generate»
			  		«ENDFOR»
			  «ELSEIF isComposite»
			  	«IF specificationState.everyEvent !== null»
			  		parallel states:
			  		  - name: region_every
			  		  «specificationState.everyEvent.generate»
		  		«ENDIF»
			  	«regions.head.generate»
			  «ELSEIF specificationState.everyEvent !== null»
			  	«specificationState.everyEvent.generate»
			  «ENDIF»
		'''
	}
	
	/**
	 * Generate the template for a final state
	 * 
	 * Normally this final states are detected in method to generate the outgoingTransitions of the others states
	 * 
	 * @param a object of FinalState
	 * 
	 * @return the template for this FinalState object
	 */
	def dispatch String generate(FinalState it) '''
		- name: «name»
		  type: final
	'''
	
	/**
	 * Generate the Choice state
	 * 
	 * Actually, it's not possible to generate this state
	 * 
	 * @param the Choice object
	 * 
	 * Not implemented
	 */
	def dispatch String generate(Choice it) {
		throw new Exception("The Choice state isn't managed by this generator...")
	}
	
	/**
	 * Generate the Synchronization,
	 * It's impossible to generate this for Sismic.
	 * This method return an exception if a Synchronization is containing in a statechart to generate
	 * 
	 * @param it : the Synchronization object containing in the statechart
	 * 
	 * @return an Exception, because it's impossible to have an equivalent in a statechart defined in Sismic 
	 */
	def dispatch String generate(Synchronization it) {
		throw new Exception("Impossible to generate the synchronization bar into statechart for Sismic...")
	}
	
	/**
	 * Generate the template for a history state
	 * 
	 * Yakindu define the history as an initial state with an attribute kind
	 * to find the enumeration of this state
	 * A history state has as value in kind attribute :
	 * 	- EntryKind.DEEP_HISTORY
	 * 	- EntryKind.SHALLOW_HISTORY
	 * 
	 * @param it : a history state
	 * 
	 * @return the template of this history state
	 */
	def dispatch String generate(Entry it) {
		var history = ""
		
		if (kind == EntryKind.DEEP_HISTORY) {
			history = "deep history"
		} else if (kind == EntryKind.SHALLOW_HISTORY) {
			history = "shallow history"
		}
		
		return '''
			- name: «name»
			  type: «history»
		'''
	}
	
	/**
	 * Generate the template for a transition of a state
	 */
	def CharSequence generate(Transition it, be.ac.umons.bol.generator.sismic.specification.Transition transition) {
		val spec = new SpecificationTransition(specification)
		
		if (target instanceof FinalState) { // It must check if the final already exists in this list
			target.name = target.parentRegion.name + "_final" + (listFinalState.length + 1)
			listFinalState.add(target as FinalState)
		}
		
		if (transition !== null && spec.haveSameTrigger(transition.specification)) { // Then add all actions into this current transition
			spec.mergeSpecification(transition.specification)
		}
		
		return '''
			- target: «target.name»
			  «spec.generate»
		'''
	}
}
